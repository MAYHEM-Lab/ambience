#include <doctest.h>
#include <tos/elf.hpp>

namespace tos::elf {
namespace {
TEST_CASE("elf parser detects errors") {
    SUBCASE("short buffers") {
        uint8_t buf[4] = {};
        auto res = elf64::from_buffer(tos::span(buf));
        REQUIRE_FALSE(res);
        REQUIRE_EQ(errors::too_short, force_error(res));
    }

    SUBCASE("bad magic") {
        uint8_t buf[256] = {};
        auto res = elf64::from_buffer(tos::span(buf));
        REQUIRE_FALSE(res);
        REQUIRE_EQ(errors::bad_magic, force_error(res));
    }
}
TEST_CASE("elf parser parses header") {
    uint8_t buf[] = {
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x3f, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x38, 0x00, 0x03, 0x00, 0x40, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x50,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xe5, 0x74, 0x64, 0x06, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    auto res = elf64::from_buffer(buf);
    REQUIRE(res);

    auto& file = force_get(res);
    REQUIRE_EQ(machine::amd64, file.header().machine);
    REQUIRE_EQ(type::executable, file.header().type);
    REQUIRE_EQ(0x1000, file.header().entry);
    REQUIRE_EQ(abi::sysv, file.header().os_abi);
    REQUIRE_EQ(endian::little, file.header().enc);

    REQUIRE_EQ(64, file.header().header_size);

    REQUIRE_EQ(64, file.header().pheader_offset);
    REQUIRE_EQ(56, file.header().pheader_size);
    REQUIRE_EQ(3, file.header().pheader_num);

    auto pheaders = file.program_headers();
    REQUIRE_EQ(segment_type::load, pheaders[0].type);
    REQUIRE_EQ(0x1000, pheaders[0].virt_address);
    REQUIRE_EQ(segment_type::load, pheaders[1].type);
}
} // namespace
} // namespace tos::elf