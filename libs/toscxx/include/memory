//
// Created by Mehmet Fatih BAKIR on 24/10/2018.
//

#pragma once

namespace std
{
    /**
     * Calls the destructor of the object pointed to by p, as if by p->~T().
     * @param p pointer to the object to destroy
     */
    template <class T>
    void destroy_at(T* p) noexcept
    {
        p->~T();
    }

    template <class _Tp, int _Idx,
            bool _CanBeEmptyBase =
            is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
    struct __compressed_pair_elem {
        typedef _Tp _ParamT;
        typedef _Tp& reference;
        typedef const _Tp& const_reference;

#ifndef _LIBCPP_CXX03_LANG
        _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() : __value_() {}

        template <class _Up, class = typename enable_if<
                !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
        >::type>
        _LIBCPP_INLINE_VISIBILITY
        constexpr explicit
        __compressed_pair_elem(_Up&& __u)
                : __value_(_VSTD::forward<_Up>(__u))
        {
        }

        template <class... _Args, size_t... _Indexes>
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
        __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                __tuple_indices<_Indexes...>)
                : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}
#else
        _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_() {}
  _LIBCPP_INLINE_VISIBILITY
  __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {}
#endif

        _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return __value_; }
        _LIBCPP_INLINE_VISIBILITY
        const_reference __get() const _NOEXCEPT { return __value_; }

    private:
        _Tp __value_;
    };

    template <class _Tp, int _Idx>
    struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
        typedef _Tp _ParamT;
        typedef _Tp& reference;
        typedef const _Tp& const_reference;
        typedef _Tp __value_type;

#ifndef _LIBCPP_CXX03_LANG
        _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() = default;

        template <class _Up, class = typename enable_if<
                !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
        >::type>
        _LIBCPP_INLINE_VISIBILITY
        constexpr explicit
        __compressed_pair_elem(_Up&& __u)
                : __value_type(_VSTD::forward<_Up>(__u))
        {}

        template <class... _Args, size_t... _Indexes>
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
        __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                __tuple_indices<_Indexes...>)
                : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}
#else
        _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_type() {}
  _LIBCPP_INLINE_VISIBILITY
  __compressed_pair_elem(_ParamT __p)
      : __value_type(std::forward<_ParamT>(__p)) {}
#endif

        _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return *this; }
        _LIBCPP_INLINE_VISIBILITY
        const_reference __get() const _NOEXCEPT { return *this; }
    };

// Tag used to construct the second element of the compressed pair.
    struct __second_tag {};

    template <class _T1, class _T2>
    class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                              private __compressed_pair_elem<_T2, 1> {
        typedef __compressed_pair_elem<_T1, 0> _Base1;
        typedef __compressed_pair_elem<_T2, 1> _Base2;

        // NOTE: This static assert should never fire because __compressed_pair
        // is *almost never* used in a scenario where it's possible for T1 == T2.
        // (The exception is std::function where it is possible that the function
        //  object and the allocator have the same type).
        static_assert((!is_same<_T1, _T2>::value),
                "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
                "The current implementation is NOT ABI-compatible with the previous "
                "implementation for this configuration");

    public:
#ifndef _LIBCPP_CXX03_LANG
        template <bool _Dummy = true,
                class = typename enable_if<
                        __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
                __dependent_type<is_default_constructible<_T2>, _Dummy>::value
        >::type
        >
        _LIBCPP_INLINE_VISIBILITY
        constexpr __compressed_pair() {}

        template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
                __compressed_pair>::value,
                bool>::type = true>
        _LIBCPP_INLINE_VISIBILITY constexpr explicit
        __compressed_pair(_Tp&& __t)
                : _Base1(std::forward<_Tp>(__t)), _Base2() {}

        template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY constexpr
        __compressed_pair(__second_tag, _Tp&& __t)
                : _Base1(), _Base2(std::forward<_Tp>(__t)) {}

        template <class _U1, class _U2>
        _LIBCPP_INLINE_VISIBILITY constexpr
        __compressed_pair(_U1&& __t1, _U2&& __t2)
                : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}

        template <class... _Args1, class... _Args2>
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                tuple<_Args2...> __second_args)
                : _Base1(__pc, _VSTD::move(__first_args),
                typename __make_tuple_indices<sizeof...(_Args1)>::type()),
                  _Base2(__pc, _VSTD::move(__second_args),
                          typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}

#else
        _LIBCPP_INLINE_VISIBILITY
  __compressed_pair() {}

  _LIBCPP_INLINE_VISIBILITY explicit
  __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) {}

  _LIBCPP_INLINE_VISIBILITY
  __compressed_pair(__second_tag, _T2 __t2)
      : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) {}

  _LIBCPP_INLINE_VISIBILITY
  __compressed_pair(_T1 __t1, _T2 __t2)
      : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) {}
#endif

        _LIBCPP_INLINE_VISIBILITY
        typename _Base1::reference first() _NOEXCEPT {
            return static_cast<_Base1&>(*this).__get();
        }

        _LIBCPP_INLINE_VISIBILITY
        typename _Base1::const_reference first() const _NOEXCEPT {
            return static_cast<_Base1 const&>(*this).__get();
        }

        _LIBCPP_INLINE_VISIBILITY
        typename _Base2::reference second() _NOEXCEPT {
            return static_cast<_Base2&>(*this).__get();
        }

        _LIBCPP_INLINE_VISIBILITY
        typename _Base2::const_reference second() const _NOEXCEPT {
            return static_cast<_Base2 const&>(*this).__get();
        }

        _LIBCPP_INLINE_VISIBILITY
        void swap(__compressed_pair& __x)
        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&
                __is_nothrow_swappable<_T2>::value)
        {
            using std::swap;
            swap(first(), __x.first());
            swap(second(), __x.second());
        }
    };

    template <class _T1, class _T2>
    inline _LIBCPP_INLINE_VISIBILITY
    void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&
            __is_nothrow_swappable<_T2>::value) {
        __x.swap(__y);
    }
}
